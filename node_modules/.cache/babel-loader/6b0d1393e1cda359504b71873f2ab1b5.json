{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\n\nvar react = require(\"react\"),\n    __assign = function () {\n  return (__assign = Object.assign || function (e) {\n    for (var t, n = 1, r = arguments.length; n < r; n++) for (var a in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);\n\n    return e;\n  }).apply(this, arguments);\n};\n\nfunction __spreadArrays() {\n  for (var e = 0, t = 0, n = arguments.length; t < n; t++) e += arguments[t].length;\n\n  var r = Array(e),\n      a = 0;\n\n  for (t = 0; t < n; t++) for (var u = arguments[t], o = 0, i = u.length; o < i; o++, a++) r[a] = u[o];\n\n  return r;\n}\n\nvar domChangeTimeout,\n    queryableKeys = {\n  meta: [\"charset\", \"name\", \"property\", \"http-equiv\"],\n  link: [\"rel\", \"sizes\"]\n},\n    createInternalTag = function (e) {\n  return function (t) {\n    var n = queryableKeys[e].map(function (e) {\n      return t.hasOwnProperty(e) ? {\n        key: e,\n        value: t[e]\n      } : void 0;\n    }).filter(Boolean),\n        r = Object.keys(t).map(function (e) {\n      return {\n        key: e,\n        value: t[e]\n      };\n    });\n    return {\n      tag: e,\n      query: n.length ? n : r,\n      attributes: t\n    };\n  };\n},\n    createInternalMeta = createInternalTag(\"meta\"),\n    createInternalLink = createInternalTag(\"link\"),\n    parseMetaConfig = function (e) {\n  var t = e.title,\n      n = e.description,\n      r = e.lang,\n      a = e.charset,\n      u = e.metas,\n      o = void 0 === u ? [] : u,\n      i = e.links,\n      s = void 0 === i ? [] : i,\n      c = e.openGraph,\n      g = void 0 === c ? {} : c,\n      m = e.twitter,\n      l = void 0 === m ? {} : m;\n  return {\n    title: t,\n    lang: r,\n    tags: __spreadArrays([!!n && {\n      tag: \"meta\",\n      query: [{\n        key: \"name\",\n        value: \"description\"\n      }],\n      attributes: {\n        name: \"description\",\n        content: n\n      }\n    }, !!a && {\n      tag: \"meta\",\n      query: [{\n        key: \"charset\"\n      }],\n      attributes: {\n        charset: a\n      }\n    }], o.map(createInternalMeta), s.map(createInternalLink), Object.keys(g).map(function (e) {\n      return createInternalMeta({\n        property: \"og:\" + e,\n        content: g[e]\n      });\n    }), Object.keys(l).map(function (e) {\n      return createInternalMeta({\n        property: \"twitter:\" + e,\n        content: l[e]\n      });\n    })).filter(function (e) {\n      return e && e.query && Object.keys(e.query).length;\n    }).reduce(function (e, t) {\n      var n,\n          r = t.query.map(function (e) {\n        var t = e.key,\n            n = void 0 === t ? \"\" : t,\n            r = e.value;\n        return n + \"=\" + (void 0 === r ? \"\" : r);\n      }).join(\"~\"),\n          a = t.tag + \"_\" + r;\n      return __assign(__assign({}, e), ((n = {})[a] = t, n));\n    }, {})\n  };\n},\n    metaStore = new Set(),\n    subscribers = new Set(),\n    mergeInstanceConfigs = function (e) {\n  return Array.from(e).map(function (e) {\n    return e.current;\n  }).reduce(function (e, t) {\n    return __assign(__assign(__assign({}, e), t), {\n      tags: __assign(__assign({}, e.tags), t.tags)\n    });\n  }, {\n    tags: {}\n  });\n},\n    emitChanges = function (e) {\n  subscribers.forEach(function (t) {\n    return t(e);\n  });\n},\n    addMetasToStore = function (e) {\n  !metaStore.has(e) && metaStore.add(e), emitChanges(mergeInstanceConfigs(metaStore));\n},\n    removeMetasFromStore = function (e) {\n  metaStore.delete(e), emitChanges(mergeInstanceConfigs(metaStore));\n},\n    subscribeToStore = function (e) {\n  return subscribers.add(e), function () {\n    subscribers.delete(e);\n  };\n},\n    getState = function () {\n  return mergeInstanceConfigs(metaStore);\n},\n    getRemovedTags = function (e, t) {\n  return Object.keys(t.tags || {}).filter(function (t) {\n    return !e.tags[t];\n  }).map(function (e) {\n    return t.tags[e];\n  });\n},\n    getTagsList = function (e) {\n  return Object.keys(e.tags || {}).map(function (t) {\n    return e.tags[t];\n  });\n},\n    getHeadElement = function (e, t) {\n  var n = t.reduce(function (e, t) {\n    var n = t.key,\n        r = t.value;\n    return e + \"[\" + n + (r ? '=\"' + r + '\"' : \"\") + \"]\";\n  }, \"\");\n  return document.head.querySelector(e + n);\n},\n    createHeadElement = function (e) {\n  var t = document.createElement(e);\n  return document.head.appendChild(t), t;\n},\n    setTitle = function (e) {\n  document.title = e;\n},\n    setLang = function (e) {\n  document.documentElement.lang = e;\n},\n    setHeadElement = function (e) {\n  var t = e.tag,\n      n = e.query,\n      r = e.attributes,\n      a = getHeadElement(t, n) || createHeadElement(t);\n  r && Object.keys(r).forEach(function (e) {\n    a.setAttribute(e, r[e] || \"\");\n  });\n},\n    removeHeadElement = function (e) {\n  var t = e.tag,\n      n = e.query,\n      r = getHeadElement(t, n);\n  r && document.head.removeChild(r);\n},\n    lastMetas = {\n  tags: {}\n},\n    updateDom = function (e, t) {\n  \"undefined\" != typeof window && (window.clearTimeout(domChangeTimeout), domChangeTimeout = setTimeout(function () {\n    var t = getRemovedTags(e, lastMetas),\n        n = getTagsList(e);\n    lastMetas = e, e.title && setTitle(e.title), e.lang && setLang(e.lang), n.forEach(setHeadElement), t.forEach(removeHeadElement);\n  }, t));\n},\n    generateMetasMarkup = function (e) {\n  return __spreadArrays([e.title ? \"<title>\" + e.title + \"</title>\" : \"\"], getTagsList(e).map(function (e) {\n    var t = e.attributes;\n    return \"<\" + e.tag + \" \" + Object.keys(t).map(function (e) {\n      return \"\" + e + (t[e] ? '=\"' + t[e] + '\"' : \"\");\n    }).join(\" \") + \" />\";\n  })).join(\"\");\n};\n\nsubscribeToStore(function (e) {\n  return updateDom(e, 50);\n});\n\nvar generateStaticHtml = function () {\n  var e = getState();\n  return generateMetasMarkup(e);\n},\n    useMetaTags = function (e, t) {\n  var n = react.useRef(),\n      r = react.useMemo(function () {\n    return parseMetaConfig(e);\n  }, t);\n  react.useEffect(function () {\n    return function () {\n      n.current && removeMetasFromStore(n);\n    };\n  }, []), n.current !== r && (n.current = r, n.current && addMetasToStore(n));\n};\n\nexports.default = useMetaTags, exports.generateStaticHtml = generateStaticHtml;","map":null,"metadata":{},"sourceType":"script"}