{"ast":null,"code":"var _jsxFileName = \"/Users/zubrah_/Desktop/New folder/Hello world/emotionify/src/pages/Sort/PlotTracks.tsx\";\nimport React from \"react\";\nimport Plot from \"react-plotly.js\";\nimport { Alert } from \"react-bootstrap\";\nimport { availableTrackAudioFeatures } from \"../../models/Spotify\";\n\nfunction getDistancePercentageAlongLineTheOfClosestPointOnLineToAnArbitaryPoint(start, end, point) {\n  // Modified from https://jsfiddle.net/soulwire/UA6H5/\n  let atob = {\n    x: end.x - start.x,\n    y: end.y - start.y\n  };\n  let atop = {\n    x: point.x - start.x,\n    y: point.y - start.y\n  };\n  let len = atob.x * atob.x + atob.y * atob.y;\n  let dot = atop.x * atob.x + atop.y * atob.y;\n  let t = Math.min(1, Math.max(0, dot / len));\n  return t;\n}\n\nfunction getPointAlongColourGradient(start_hex_colour, end_hex_colour, percentage) {\n  const hex = x => {\n    let tmp = x.toString(16);\n    return tmp.length === 1 ? \"0\" + tmp : tmp;\n  };\n\n  var r = Math.ceil(parseInt(end_hex_colour.substring(0, 2), 16) * percentage + parseInt(start_hex_colour.substring(0, 2), 16) * (1 - percentage));\n  var g = Math.ceil(parseInt(end_hex_colour.substring(2, 4), 16) * percentage + parseInt(start_hex_colour.substring(2, 4), 16) * (1 - percentage));\n  var b = Math.ceil(parseInt(end_hex_colour.substring(4, 6), 16) * percentage + parseInt(start_hex_colour.substring(4, 6), 16) * (1 - percentage));\n  return hex(r) + hex(g) + hex(b);\n}\n\nconst PlotTracks = props => {\n  const {\n    tracks,\n    x_audio_feature_name,\n    y_audio_feature_name\n  } = props;\n  const x_audio_feature = availableTrackAudioFeatures[x_audio_feature_name];\n  const y_audio_feature = availableTrackAudioFeatures[y_audio_feature_name];\n  const points = tracks.map(t => {\n    const track = {\n      id: t.id,\n      title: t.name,\n      artist: t.artists.map(a => a.name).join(\", \"),\n      length: t.duration_ms\n    };\n\n    if (t.audio_features !== undefined && t.audio_features !== null) {\n      const x = t.audio_features[x_audio_feature.key];\n      const y = t.audio_features[y_audio_feature.key];\n      return {\n        x: x,\n        y: y,\n        track: track\n      };\n    } else if (t.audio_features === undefined) {\n      // Commonly occurs as t.audio_features === undefined on first playlist selection\n      return {\n        x: 0,\n        y: 0,\n        track: track\n      };\n    } else {\n      // t.audio_features === null when no audio features could be found (ignore these then - we should not plot them)\n      return null;\n    }\n  }).filter(sp => sp !== null); // Max and min points in the data\n\n  const points_x_min = Math.min(...points.map(p => p.x));\n  const points_y_min = Math.min(...points.map(p => p.y));\n  const points_x_max = Math.max(...points.map(p => p.x));\n  const points_y_max = Math.max(...points.map(p => p.y)); // Mix expected and actual min's and max's to defined the colour gradient\n\n  const colour_x_min = x_audio_feature.min !== undefined ? Math.min(x_audio_feature.min, points_x_min) : points_x_min;\n  const colour_x_max = x_audio_feature.max !== undefined ? Math.max(x_audio_feature.max, points_x_max) : points_x_max;\n  const colour_y_min = y_audio_feature.min !== undefined ? Math.min(y_audio_feature.min, points_y_min) : points_y_min;\n  const colour_y_max = y_audio_feature.max !== undefined ? Math.max(y_audio_feature.max, points_y_max) : points_y_max; // The min and max are passed in, but still take the points into account just incase there are values outside of the defined range\n\n  const scale_x_min = x_audio_feature.min !== undefined ? Math.min(x_audio_feature.min, points_x_min) : undefined;\n  const scale_x_max = x_audio_feature.max !== undefined ? Math.max(x_audio_feature.max, points_x_max) : undefined;\n  const scale_y_min = y_audio_feature.min !== undefined ? Math.min(y_audio_feature.min, points_y_min) : undefined;\n  const scale_y_max = y_audio_feature.max !== undefined ? Math.max(y_audio_feature.max, points_y_max) : undefined;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Plot, {\n    data: [{\n      y: points.map(p => p.y),\n      x: points.map(p => p.x),\n      text: points.map(p => \"Title: \" + p.track.title + \"<br>Artist: \" + p.track.artist + \"<br>\" + x_audio_feature_name + \": \" + p.x + \"<br>\" + y_audio_feature_name + \": \" + p.y),\n      hoverinfo: \"text\",\n      mode: \"lines+markers\",\n      marker: {\n        size: 10,\n        color: points.map(p => {\n          let distanceAlongGradient = getDistancePercentageAlongLineTheOfClosestPointOnLineToAnArbitaryPoint({\n            x: colour_x_min,\n            y: colour_y_min\n          }, {\n            x: colour_x_max,\n            y: colour_y_max\n          }, {\n            x: p.x,\n            y: p.y\n          });\n          return \"#\" + getPointAlongColourGradient(\"00529d\", \"eb121b\", distanceAlongGradient);\n        })\n      },\n      line: {\n        color: \"rgba(44, 48, 51, 0.5)\",\n        width: 1\n      }\n    }],\n    layout: {\n      hovermode: \"closest\",\n      margin: {\n        t: 0,\n        b: 0,\n        l: 0,\n        r: 0\n      },\n      plot_bgcolor: \"transparent\",\n      paper_bgcolor: \"transparent\",\n      xaxis: {\n        range: [scale_x_min, scale_x_max]\n      },\n      yaxis: {\n        range: [scale_y_min, scale_y_max]\n      }\n    },\n    useResizeHandler: true,\n    config: {\n      displayModeBar: false,\n      responsive: true\n    },\n    className: \"w-100 m-auto overflow-hidden\",\n    style: {\n      maxWidth: 700,\n      height: 450,\n      border: \"2px solid #6c757d\",\n      borderRadius: 10\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 122,\n      columnNumber: 7\n    }\n  }), tracks.filter(a => a.audio_features === null).length > 0 && /*#__PURE__*/React.createElement(Alert, {\n    variant: \"warning\",\n    className: \"mt-2 d-inline-block\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 187,\n      columnNumber: 9\n    }\n  }, \"Warning: Some songs are missing audio features.\", /*#__PURE__*/React.createElement(\"br\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 189,\n      columnNumber: 11\n    }\n  }), \"Look in the table below to identify these songs (they will have no values beside them).\"));\n};\n\nexport default PlotTracks;","map":{"version":3,"sources":["/Users/zubrah_/Desktop/New folder/Hello world/emotionify/src/pages/Sort/PlotTracks.tsx"],"names":["React","Plot","Alert","availableTrackAudioFeatures","getDistancePercentageAlongLineTheOfClosestPointOnLineToAnArbitaryPoint","start","end","point","atob","x","y","atop","len","dot","t","Math","min","max","getPointAlongColourGradient","start_hex_colour","end_hex_colour","percentage","hex","tmp","toString","length","r","ceil","parseInt","substring","g","b","PlotTracks","props","tracks","x_audio_feature_name","y_audio_feature_name","x_audio_feature","y_audio_feature","points","map","track","id","title","name","artist","artists","a","join","duration_ms","audio_features","undefined","key","filter","sp","points_x_min","p","points_y_min","points_x_max","points_y_max","colour_x_min","colour_x_max","colour_y_min","colour_y_max","scale_x_min","scale_x_max","scale_y_min","scale_y_max","text","hoverinfo","mode","marker","size","color","distanceAlongGradient","line","width","hovermode","margin","l","plot_bgcolor","paper_bgcolor","xaxis","range","yaxis","displayModeBar","responsive","maxWidth","height","border","borderRadius"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport Plot from \"react-plotly.js\";\nimport { Alert } from \"react-bootstrap\";\nimport { TrackWithAudioFeatures, availableTrackAudioFeatures } from \"../../models/Spotify\";\n\ninterface IProps {\n  tracks: TrackWithAudioFeatures[];\n  x_audio_feature_name: string;\n  y_audio_feature_name: string;\n}\n\ninterface Point {\n  x: number;\n  y: number;\n}\n\ninterface TrackPoint extends Point {\n  track: {\n    id: string;\n    title: string;\n    artist: string;\n    length: number;\n  };\n}\n\nfunction getDistancePercentageAlongLineTheOfClosestPointOnLineToAnArbitaryPoint(\n  start: Point,\n  end: Point,\n  point: Point\n): number {\n  // Modified from https://jsfiddle.net/soulwire/UA6H5/\n  let atob = { x: end.x - start.x, y: end.y - start.y };\n  let atop = { x: point.x - start.x, y: point.y - start.y };\n  let len = atob.x * atob.x + atob.y * atob.y;\n  let dot = atop.x * atob.x + atop.y * atob.y;\n  let t = Math.min(1, Math.max(0, dot / len));\n  return t;\n}\n\nfunction getPointAlongColourGradient(\n  start_hex_colour: string,\n  end_hex_colour: string,\n  percentage: number\n): string {\n  const hex = (x: number): string => {\n    let tmp = x.toString(16);\n    return tmp.length === 1 ? \"0\" + tmp : tmp;\n  };\n\n  var r = Math.ceil(\n    parseInt(end_hex_colour.substring(0, 2), 16) * percentage +\n      parseInt(start_hex_colour.substring(0, 2), 16) * (1 - percentage)\n  );\n  var g = Math.ceil(\n    parseInt(end_hex_colour.substring(2, 4), 16) * percentage +\n      parseInt(start_hex_colour.substring(2, 4), 16) * (1 - percentage)\n  );\n  var b = Math.ceil(\n    parseInt(end_hex_colour.substring(4, 6), 16) * percentage +\n      parseInt(start_hex_colour.substring(4, 6), 16) * (1 - percentage)\n  );\n  return hex(r) + hex(g) + hex(b);\n}\n\nconst PlotTracks: React.FunctionComponent<IProps> = (props: IProps) => {\n  const { tracks, x_audio_feature_name, y_audio_feature_name } = props;\n\n  const x_audio_feature = availableTrackAudioFeatures[x_audio_feature_name];\n  const y_audio_feature = availableTrackAudioFeatures[y_audio_feature_name];\n\n  const points: TrackPoint[] = tracks\n    .map((t) => {\n      const track = {\n        id: t.id,\n        title: t.name,\n        artist: t.artists.map((a) => a.name).join(\", \"),\n        length: t.duration_ms\n      };\n\n      if (t.audio_features !== undefined && t.audio_features !== null) {\n        const x = t.audio_features[x_audio_feature.key] as number;\n        const y = t.audio_features[y_audio_feature.key] as number;\n        return { x: x, y: y, track: track };\n      } else if (t.audio_features === undefined) {\n        // Commonly occurs as t.audio_features === undefined on first playlist selection\n        return { x: 0, y: 0, track: track };\n      } else {\n        // t.audio_features === null when no audio features could be found (ignore these then - we should not plot them)\n        return null;\n      }\n    })\n    .filter((sp): sp is TrackPoint => sp !== null);\n\n  // Max and min points in the data\n  const points_x_min: number = Math.min(...points.map((p) => p.x));\n  const points_y_min: number = Math.min(...points.map((p) => p.y));\n  const points_x_max: number = Math.max(...points.map((p) => p.x));\n  const points_y_max: number = Math.max(...points.map((p) => p.y));\n\n  // Mix expected and actual min's and max's to defined the colour gradient\n  const colour_x_min: number =\n    x_audio_feature.min !== undefined ? Math.min(x_audio_feature.min, points_x_min) : points_x_min;\n  const colour_x_max: number =\n    x_audio_feature.max !== undefined ? Math.max(x_audio_feature.max, points_x_max) : points_x_max;\n  const colour_y_min: number =\n    y_audio_feature.min !== undefined ? Math.min(y_audio_feature.min, points_y_min) : points_y_min;\n  const colour_y_max: number =\n    y_audio_feature.max !== undefined ? Math.max(y_audio_feature.max, points_y_max) : points_y_max;\n\n  // The min and max are passed in, but still take the points into account just incase there are values outside of the defined range\n  const scale_x_min: number | undefined =\n    x_audio_feature.min !== undefined ? Math.min(x_audio_feature.min, points_x_min) : undefined;\n  const scale_x_max: number | undefined =\n    x_audio_feature.max !== undefined ? Math.max(x_audio_feature.max, points_x_max) : undefined;\n  const scale_y_min: number | undefined =\n    y_audio_feature.min !== undefined ? Math.min(y_audio_feature.min, points_y_min) : undefined;\n  const scale_y_max: number | undefined =\n    y_audio_feature.max !== undefined ? Math.max(y_audio_feature.max, points_y_max) : undefined;\n\n  return (\n    <>\n      <Plot\n        data={[\n          {\n            y: points.map((p) => p.y),\n            x: points.map((p) => p.x),\n            text: points.map(\n              (p) =>\n                \"Title: \" +\n                p.track.title +\n                \"<br>Artist: \" +\n                p.track.artist +\n                \"<br>\" +\n                x_audio_feature_name +\n                \": \" +\n                p.x +\n                \"<br>\" +\n                y_audio_feature_name +\n                \": \" +\n                p.y\n            ),\n            hoverinfo: \"text\",\n            mode: \"lines+markers\",\n            marker: {\n              size: 10,\n              color: points.map((p) => {\n                let distanceAlongGradient = getDistancePercentageAlongLineTheOfClosestPointOnLineToAnArbitaryPoint(\n                  { x: colour_x_min, y: colour_y_min },\n                  { x: colour_x_max, y: colour_y_max },\n                  { x: p.x, y: p.y }\n                );\n                return \"#\" + getPointAlongColourGradient(\"00529d\", \"eb121b\", distanceAlongGradient);\n              })\n            },\n            line: {\n              color: \"rgba(44, 48, 51, 0.5)\",\n              width: 1\n            }\n          }\n        ]}\n        layout={{\n          hovermode: \"closest\",\n          margin: { t: 0, b: 0, l: 0, r: 0 },\n          plot_bgcolor: \"transparent\",\n          paper_bgcolor: \"transparent\",\n          xaxis: {\n            range: [scale_x_min, scale_x_max]\n          },\n          yaxis: {\n            range: [scale_y_min, scale_y_max]\n          }\n        }}\n        useResizeHandler={true}\n        config={{\n          displayModeBar: false,\n          responsive: true\n        }}\n        className=\"w-100 m-auto overflow-hidden\"\n        style={{\n          maxWidth: 700,\n          height: 450,\n          border: \"2px solid #6c757d\",\n          borderRadius: 10\n        }}\n      />\n      {tracks.filter((a) => a.audio_features === null).length > 0 && (\n        <Alert variant=\"warning\" className=\"mt-2 d-inline-block\">\n          Warning: Some songs are missing audio features.\n          <br />\n          Look in the table below to identify these songs (they will have no values beside them).\n        </Alert>\n      )}\n    </>\n  );\n};\n\nexport default PlotTracks;\n"]},"metadata":{},"sourceType":"module"}