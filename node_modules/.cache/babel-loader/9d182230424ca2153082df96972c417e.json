{"ast":null,"code":"import SpotifyWebApi from \"spotify-web-api-js\";\nimport { chunkList } from \"./Utils\";\nconst playlistRequestLimit = 20;\nconst playlistTrackRequestLimit = 100;\nconst trackFeaturesRequestLimit = 100;\nconst maxRequestsSentAtOnce = 10;\n\nfunction offsetCalculation(limit, total) {\n  // Calculate request offsets needed to be performed\n  let request_blocks = [];\n  let accounted_for = 0;\n\n  for (let i = 0; accounted_for < total; i++) {\n    request_blocks.push({\n      offset: i * limit,\n      limit: limit\n    });\n    accounted_for += limit;\n  }\n\n  return request_blocks;\n}\n\nexport function getAllSpotifyUsersPlaylists(token, user) {\n  // Gets all playlists for a user. Fast as it makes more than one request a time.\n  return new Promise((resolve, reject) => {\n    const spotifyApi = new SpotifyWebApi();\n    spotifyApi.setAccessToken(token.value);\n    let playlists = [];\n    const offset = 0;\n    const limit = playlistRequestLimit;\n    let rejected = false;\n    spotifyApi.getUserPlaylists(user.id, {\n      offset,\n      limit\n    }).then(async data => {\n      playlists = [...playlists, ...data.items]; // Store data from initial request\n      // Calculate requests to be made and chunk them\n\n      const request_blocks = offsetCalculation(limit, data.total).splice(1); // Ignore the first as we have already made that request\n\n      const request_blocks_chunked = chunkList(request_blocks, maxRequestsSentAtOnce);\n\n      for (let i = 0; i < request_blocks_chunked.length; i++) {\n        // Start all requests in this chunk\n        let promises = [];\n\n        for (let j = 0; j < request_blocks_chunked[i].length; j++) {\n          promises.push(spotifyApi.getUserPlaylists(user.id, request_blocks_chunked[i][j]));\n        } // Wait for each request and get data\n\n\n        await Promise.all(promises).then(new_playlists => {\n          playlists = [...playlists, ...new_playlists.map(i => i.items).flat()];\n        }).catch(err => {\n          reject(err);\n          rejected = true;\n        });\n\n        if (rejected) {\n          break;\n        }\n      } // Convert to PlaylistObjectSimplifiedWithTrackIds using a blank list\n\n\n      resolve(playlists.map(p => {\n        return { ...p,\n          track_ids: []\n        };\n      }));\n    }, err => {\n      reject(err);\n    });\n  });\n}\nexport function getAllTracksInPlaylist(token, playlist) {\n  // Gets all tracks in a playlist. Fast as it makes more than one request a time.\n  return new Promise((resolve, reject) => {\n    const spotifyApi = new SpotifyWebApi();\n    spotifyApi.setAccessToken(token.value);\n    let tracks = [];\n    const offset = 0;\n    const limit = playlistTrackRequestLimit;\n    let rejected = false;\n    spotifyApi.getPlaylistTracks(playlist.id, {\n      offset,\n      limit\n    }).then(async data => {\n      tracks = [...tracks, ...data.items.map(i => i.track)]; // Store data from initial request\n      // Calculate requests to be made and chunk them\n\n      const request_blocks = offsetCalculation(limit, data.total).splice(1); // Ignore the first as we have already made that request\n\n      const request_blocks_chunked = chunkList(request_blocks, maxRequestsSentAtOnce);\n\n      for (let i = 0; i < request_blocks_chunked.length; i++) {\n        // Start all requests in this chunk\n        let promises = [];\n\n        for (let j = 0; j < request_blocks_chunked[i].length; j++) {\n          promises.push(spotifyApi.getPlaylistTracks(playlist.id, request_blocks_chunked[i][j]));\n        } // Wait for each request and get data\n\n\n        await Promise.all(promises).then(new_tracks => {\n          tracks = [...tracks, ...new_tracks.map(i => i.items).flat().map(i => i.track)];\n        }).catch(err => {\n          reject(err);\n          rejected = true;\n        });\n\n        if (rejected) {\n          break;\n        }\n      }\n\n      resolve(tracks.map(t => {\n        return { ...t,\n          audio_features: undefined\n        };\n      }));\n    }, err => {\n      reject(err);\n    });\n  });\n}\nexport function getAudioFeaturesForTracks(token, track_ids) {\n  // Gets all the audio features for a list of tracks. Fast as it makes more than one request a time.\n  return new Promise(async (resolve, reject) => {\n    const spotifyApi = new SpotifyWebApi();\n    spotifyApi.setAccessToken(token.value);\n    let features = [];\n    const track_groups = chunkList(track_ids, trackFeaturesRequestLimit); // Tracks for each request\n\n    const track_groups_chunked = chunkList(track_groups, maxRequestsSentAtOnce); // Batches of requests\n\n    let rejected = false;\n\n    for (let i = 0; i < track_groups_chunked.length; i++) {\n      // Start all requests in this chunk\n      let promises = [];\n\n      for (let j = 0; j < track_groups_chunked[i].length; j++) {\n        promises.push(spotifyApi.getAudioFeaturesForTracks(track_groups_chunked[i][j]));\n      } // Wait for each request and get data\n\n\n      await Promise.all(promises).then(new_features => {\n        features = [...features, ...new_features.map(i => i.audio_features).flat()];\n      }).catch(err => {\n        reject(err);\n        rejected = true;\n      });\n\n      if (rejected) {\n        break;\n      }\n    } // if (!rejected) {\n    // }\n\n\n    resolve(features);\n  });\n}\nexport function createPlaylist(token, user, name, isPublic, track_uris) {\n  return new Promise((resolve, reject) => {\n    const spotifyApi = new SpotifyWebApi();\n    spotifyApi.setAccessToken(token);\n    return spotifyApi.createPlaylist(user.id, {\n      name: name,\n      public: isPublic,\n      description: \"Created by emotionify.nitratine.net\"\n    }).then(async playlist => {\n      // Chunk into blocks of 100\n      const chunks = chunkList(track_uris, 100); // Add tracks in order\n\n      for (let i = 0; i < chunks.length; i++) {\n        await spotifyApi.addTracksToPlaylist(playlist.id, chunks[i]).catch(err => reject(err));\n      } // Manually set the amount of tracks rather than requesting for it again\n\n\n      playlist.tracks.total = track_uris.length;\n      resolve({ ...playlist,\n        track_ids: []\n      });\n    }, err => {\n      reject(err);\n    });\n  });\n} // Get audio feature objects for tracks in a playlist that exist (aren't undefined for null) using all tracks requested\n\nexport function getSupportedTrackAudioFeaturesFromPlaylist(playlist, tracks) {\n  return playlist.track_ids // Get the playlists tracks\n  .filter(tid => tid in tracks) // Make sure the track exists\n  .map(tid => tracks[tid].audio_features) // Get all audio features\n  .filter(af => af !== undefined && af !== null); // Filter out invalid audio features\n}","map":{"version":3,"sources":["/Users/zubrah_/Desktop/New folder/Hello world/emotionify/src/logic/Spotify.ts"],"names":["SpotifyWebApi","chunkList","playlistRequestLimit","playlistTrackRequestLimit","trackFeaturesRequestLimit","maxRequestsSentAtOnce","offsetCalculation","limit","total","request_blocks","accounted_for","i","push","offset","getAllSpotifyUsersPlaylists","token","user","Promise","resolve","reject","spotifyApi","setAccessToken","value","playlists","rejected","getUserPlaylists","id","then","data","items","splice","request_blocks_chunked","length","promises","j","all","new_playlists","map","flat","catch","err","p","track_ids","getAllTracksInPlaylist","playlist","tracks","getPlaylistTracks","track","new_tracks","t","audio_features","undefined","getAudioFeaturesForTracks","features","track_groups","track_groups_chunked","new_features","createPlaylist","name","isPublic","track_uris","public","description","chunks","addTracksToPlaylist","getSupportedTrackAudioFeaturesFromPlaylist","filter","tid","af"],"mappings":"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","sourcesContent":["import SpotifyWebApi from \"spotify-web-api-js\";\nimport { chunkList } from \"./Utils\";\nimport {\n  Token,\n  PlaylistObjectSimplifiedWithTrackIds,\n  TrackWithAudioFeatures\n} from \"../models/Spotify\";\n\nconst playlistRequestLimit = 20;\nconst playlistTrackRequestLimit = 100;\nconst trackFeaturesRequestLimit = 100;\nconst maxRequestsSentAtOnce = 10;\n\nexport interface OffsetLimit {\n  offset: number;\n  limit: number;\n}\n\nfunction offsetCalculation(limit: number, total: number): OffsetLimit[] {\n  // Calculate request offsets needed to be performed\n  let request_blocks: OffsetLimit[] = [];\n  let accounted_for = 0;\n  for (let i = 0; accounted_for < total; i++) {\n    request_blocks.push({ offset: i * limit, limit: limit });\n    accounted_for += limit;\n  }\n  return request_blocks;\n}\n\nexport function getAllSpotifyUsersPlaylists(\n  token: Token,\n  user: SpotifyApi.UserObjectPrivate\n): Promise<PlaylistObjectSimplifiedWithTrackIds[]> {\n  // Gets all playlists for a user. Fast as it makes more than one request a time.\n  return new Promise((resolve, reject) => {\n    const spotifyApi = new SpotifyWebApi();\n    spotifyApi.setAccessToken(token.value);\n\n    let playlists: SpotifyApi.PlaylistObjectSimplified[] = [];\n    const offset = 0;\n    const limit = playlistRequestLimit;\n\n    let rejected = false;\n\n    spotifyApi.getUserPlaylists(user.id, { offset, limit }).then(\n      async (data) => {\n        playlists = [...playlists, ...data.items]; // Store data from initial request\n\n        // Calculate requests to be made and chunk them\n        const request_blocks = offsetCalculation(limit, data.total).splice(1); // Ignore the first as we have already made that request\n        const request_blocks_chunked = chunkList(request_blocks, maxRequestsSentAtOnce);\n\n        for (let i = 0; i < request_blocks_chunked.length; i++) {\n          // Start all requests in this chunk\n          let promises: Promise<SpotifyApi.ListOfUsersPlaylistsResponse>[] = [];\n          for (let j = 0; j < request_blocks_chunked[i].length; j++) {\n            promises.push(spotifyApi.getUserPlaylists(user.id, request_blocks_chunked[i][j]));\n          }\n          // Wait for each request and get data\n          await Promise.all(promises)\n            .then((new_playlists) => {\n              playlists = [...playlists, ...new_playlists.map((i) => i.items).flat()];\n            })\n            .catch((err) => {\n              reject(err);\n              rejected = true;\n            });\n          if (rejected) {\n            break;\n          }\n        }\n\n        // Convert to PlaylistObjectSimplifiedWithTrackIds using a blank list\n        resolve(\n          playlists.map((p) => {\n            return { ...p, track_ids: [] };\n          })\n        );\n      },\n      (err) => {\n        reject(err);\n      }\n    );\n  });\n}\n\nexport function getAllTracksInPlaylist(\n  token: Token,\n  playlist: SpotifyApi.PlaylistObjectSimplified\n): Promise<TrackWithAudioFeatures[]> {\n  // Gets all tracks in a playlist. Fast as it makes more than one request a time.\n  return new Promise((resolve, reject) => {\n    const spotifyApi = new SpotifyWebApi();\n    spotifyApi.setAccessToken(token.value);\n\n    let tracks: SpotifyApi.TrackObjectFull[] = [];\n    const offset = 0;\n    const limit = playlistTrackRequestLimit;\n\n    let rejected = false;\n\n    spotifyApi.getPlaylistTracks(playlist.id, { offset, limit }).then(\n      async (data) => {\n        tracks = [...tracks, ...data.items.map((i) => i.track)]; // Store data from initial request\n\n        // Calculate requests to be made and chunk them\n        const request_blocks = offsetCalculation(limit, data.total).splice(1); // Ignore the first as we have already made that request\n        const request_blocks_chunked = chunkList(request_blocks, maxRequestsSentAtOnce);\n\n        for (let i = 0; i < request_blocks_chunked.length; i++) {\n          // Start all requests in this chunk\n          let promises: Promise<SpotifyApi.PlaylistTrackResponse>[] = [];\n          for (let j = 0; j < request_blocks_chunked[i].length; j++) {\n            promises.push(spotifyApi.getPlaylistTracks(playlist.id, request_blocks_chunked[i][j]));\n          }\n          // Wait for each request and get data\n          await Promise.all(promises)\n            .then((new_tracks) => {\n              tracks = [\n                ...tracks,\n                ...new_tracks\n                  .map((i) => i.items)\n                  .flat()\n                  .map((i) => i.track)\n              ];\n            })\n            .catch((err) => {\n              reject(err);\n              rejected = true;\n            });\n          if (rejected) {\n            break;\n          }\n        }\n\n        resolve(\n          tracks.map((t) => {\n            return { ...t, audio_features: undefined };\n          })\n        );\n      },\n      (err) => {\n        reject(err);\n      }\n    );\n  });\n}\n\nexport function getAudioFeaturesForTracks(\n  token: Token,\n  track_ids: string[]\n): Promise<SpotifyApi.AudioFeaturesObject[]> {\n  // Gets all the audio features for a list of tracks. Fast as it makes more than one request a time.\n  return new Promise(async (resolve, reject) => {\n    const spotifyApi = new SpotifyWebApi();\n    spotifyApi.setAccessToken(token.value);\n\n    let features: SpotifyApi.AudioFeaturesObject[] = [];\n    const track_groups = chunkList(track_ids, trackFeaturesRequestLimit); // Tracks for each request\n    const track_groups_chunked = chunkList(track_groups, maxRequestsSentAtOnce); // Batches of requests\n\n    let rejected = false;\n\n    for (let i = 0; i < track_groups_chunked.length; i++) {\n      // Start all requests in this chunk\n      let promises: Promise<SpotifyApi.MultipleAudioFeaturesResponse>[] = [];\n      for (let j = 0; j < track_groups_chunked[i].length; j++) {\n        promises.push(spotifyApi.getAudioFeaturesForTracks(track_groups_chunked[i][j]));\n      }\n      // Wait for each request and get data\n      await Promise.all(promises)\n        .then((new_features) => {\n          features = [...features, ...new_features.map((i) => i.audio_features).flat()];\n        })\n        .catch((err) => {\n          reject(err);\n          rejected = true;\n        });\n      if (rejected) {\n        break;\n      }\n    }\n\n    // if (!rejected) {\n\n    // }\n    resolve(features);\n  });\n}\n\nexport function createPlaylist(\n  token: string,\n  user: SpotifyApi.UserObjectPrivate,\n  name: string,\n  isPublic: boolean,\n  track_uris: string[]\n): Promise<PlaylistObjectSimplifiedWithTrackIds> {\n  return new Promise((resolve, reject) => {\n    const spotifyApi = new SpotifyWebApi();\n    spotifyApi.setAccessToken(token);\n\n    return spotifyApi\n      .createPlaylist(user.id, {\n        name: name,\n        public: isPublic,\n        description: \"Created by emotionify.nitratine.net\"\n      })\n      .then(\n        async (playlist) => {\n          // Chunk into blocks of 100\n          const chunks: string[][] = chunkList(track_uris, 100);\n\n          // Add tracks in order\n          for (let i = 0; i < chunks.length; i++) {\n            await spotifyApi\n              .addTracksToPlaylist(playlist.id, chunks[i])\n              .catch((err) => reject(err));\n          }\n\n          // Manually set the amount of tracks rather than requesting for it again\n          playlist.tracks.total = track_uris.length;\n          resolve({ ...playlist, track_ids: [] });\n        },\n        (err) => {\n          reject(err);\n        }\n      );\n  });\n}\n\n// Get audio feature objects for tracks in a playlist that exist (aren't undefined for null) using all tracks requested\nexport function getSupportedTrackAudioFeaturesFromPlaylist(\n  playlist: PlaylistObjectSimplifiedWithTrackIds,\n  tracks: { [key: string]: TrackWithAudioFeatures }\n): SpotifyApi.AudioFeaturesObject[] {\n  return playlist.track_ids // Get the playlists tracks\n    .filter((tid) => tid in tracks) // Make sure the track exists\n    .map((tid) => tracks[tid].audio_features) // Get all audio features\n    .filter((af): af is SpotifyApi.AudioFeaturesObject => af !== undefined && af !== null); // Filter out invalid audio features\n}\n"]},"metadata":{},"sourceType":"module"}