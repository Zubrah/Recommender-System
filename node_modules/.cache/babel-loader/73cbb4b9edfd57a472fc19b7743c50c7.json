{"ast":null,"code":"/*\n * Different methods of sorting x y points\n */\n// Not used here but relates to methods here\nexport const availableSortingMethods = {\n  \"Distance From Origin\": originDistance,\n  \"Nearest Neighbour\": nearestNeighbourFromOrigin,\n  \"X Axis\": xAxis,\n  \"Y Axis\": yAxis,\n  \"No Sorting\": noSort\n};\n\nfunction distanceToPoint(xOrigin, yOrigin, x, y) {\n  let a = xOrigin - x;\n  let b = yOrigin - y;\n  return Math.sqrt(a * a + b * b);\n} // Sort points based off their distance from the origin. Not great as it could jump from 1,0 to 0,1\n\n\nexport function originDistance(points) {\n  let distances_from_origin = points.map(p => {\n    return { ...p,\n      distance: distanceToPoint(0, 0, p.x, p.y)\n    };\n  });\n  return distances_from_origin.sort((a, b) => a.distance - b.distance);\n} // Sorts points by going point to point based off the closest left-over points. Starts at 0,0.\n\nexport function nearestNeighbourFromOrigin(points) {\n  if (points.length === 0) {\n    return [];\n  }\n\n  let nearest_point_to_origin = points.reduce((accumulator, currentValue) => {\n    let acc_dist = distanceToPoint(0, 0, accumulator.x, accumulator.y);\n    let curr_dist = distanceToPoint(0, 0, currentValue.x, currentValue.y);\n    return acc_dist > curr_dist ? currentValue : accumulator;\n  });\n  let sorted_points = [nearest_point_to_origin]; // Put the closest point to 0, 0 in the sorted list\n\n  let points_left = points.slice(); // Make a copy\n\n  points_left = points_left.filter(p => p.id !== nearest_point_to_origin.id); // Remove nearest point\n\n  let current_point = nearest_point_to_origin;\n\n  const reduce_to_closest_point = (accumulator, currentValue) => {\n    // Keep function out of the loop\n    let acc_dist = distanceToPoint(current_point.x, current_point.y, accumulator.x, accumulator.y);\n    let curr_dist = distanceToPoint(current_point.x, current_point.y, currentValue.x, currentValue.y);\n    return acc_dist > curr_dist ? currentValue : accumulator;\n  };\n\n  while (points_left.length > 0) {\n    let closest_point = points_left.reduce(reduce_to_closest_point);\n    sorted_points.push(closest_point);\n    points_left = points_left.filter(p => p.id !== closest_point.id);\n    current_point = closest_point;\n  }\n\n  return sorted_points;\n} // Return the data provided\n\nexport function noSort(points) {\n  return points;\n} // Sort by x\n\nexport function xAxis(points) {\n  return points.sort((a, b) => {\n    return a.x === b.x ? 0 : a.x > b.x ? 1 : -1;\n  });\n} // Sort by y\n\nexport function yAxis(points) {\n  return points.sort((a, b) => {\n    return a.y === b.y ? 0 : a.y > b.y ? 1 : -1;\n  });\n} // Sort tracks given x and y features and a sorting method\n\nexport function sort(tracks, x_audio_feature, y_audio_feature, sorting_method) {\n  // Get points initial indexes (to calculate movement)\n  let tracks_with_playlist_indexes = tracks.map((t, i) => {\n    return {\n      id: t.id,\n      index: {\n        before: i,\n        after: 0\n      }\n    };\n  }); // Convert tracks to sortable points\n\n  let tracks_as_sp = tracks.map(t => {\n    if (t.audio_features !== undefined && t.audio_features !== null) {\n      let x = t.audio_features[x_audio_feature]; // We know better than the compiler\n\n      let y = t.audio_features[y_audio_feature];\n      return {\n        id: t.id,\n        x: x,\n        y: y\n      };\n    } else {\n      // Commonly occurs as t.audioFeatures === undefined on first playlist selection\n      return {\n        id: t.id,\n        x: 0,\n        y: 0\n      };\n    }\n  }); // Sort the sortable points\n\n  let tracks_as_sp_sorted = sorting_method(tracks_as_sp); // Calculate new indexes using the sorted points\n\n  let tracks_with_sorted_indexes = tracks_as_sp_sorted.map((sp, i) => {\n    let track = tracks_with_playlist_indexes.find(t => t.id === sp.id);\n\n    if (track !== undefined) {\n      return { ...track,\n        index: {\n          before: track.index.before,\n          after: i\n        }\n      };\n    } else {\n      console.error(\"[TrackTable:tracks_with_sorted_indexes] Cannot find match for: \" + sp.id);\n      return null;\n    }\n  }).filter(t => t !== null); // Quick debugging verification\n\n  if (tracks_with_sorted_indexes.length !== tracks.length) {\n    console.error(\"PointSorting.sort did not output the same amount of tracks input\");\n  } // Sort tracks by the new indexes\n\n\n  return tracks_with_sorted_indexes.sort((a, b) => a.index.after - b.index.after);\n}","map":{"version":3,"sources":["/Users/zubrah_/Desktop/New folder/Hello world/emotionify/src/logic/PointSorting.ts"],"names":["availableSortingMethods","originDistance","nearestNeighbourFromOrigin","xAxis","yAxis","noSort","distanceToPoint","xOrigin","yOrigin","x","y","a","b","Math","sqrt","points","distances_from_origin","map","p","distance","sort","length","nearest_point_to_origin","reduce","accumulator","currentValue","acc_dist","curr_dist","sorted_points","points_left","slice","filter","id","current_point","reduce_to_closest_point","closest_point","push","tracks","x_audio_feature","y_audio_feature","sorting_method","tracks_with_playlist_indexes","t","i","index","before","after","tracks_as_sp","audio_features","undefined","tracks_as_sp_sorted","tracks_with_sorted_indexes","sp","track","find","console","error"],"mappings":"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","sourcesContent":["import { TrackWithAudioFeatures } from \"../models/Spotify\";\n\n/*\n * Different methods of sorting x y points\n */\n\nexport interface SortablePoint {\n  id: any;\n  x: number;\n  y: number;\n}\n\nexport interface IndexedTrackId {\n  // Minimal stored data\n  id: string;\n  index: {\n    before: number;\n    after: number;\n  };\n}\n\nexport interface SpotifyTrackWithIndexes extends TrackWithAudioFeatures, IndexedTrackId {} // Not used here but relates to methods here\n\nexport const availableSortingMethods: { [key: string]: Function } = {\n  \"Distance From Origin\": originDistance,\n  \"Nearest Neighbour\": nearestNeighbourFromOrigin,\n  \"X Axis\": xAxis,\n  \"Y Axis\": yAxis,\n  \"No Sorting\": noSort\n};\n\nfunction distanceToPoint(xOrigin: number, yOrigin: number, x: number, y: number): number {\n  let a = xOrigin - x;\n  let b = yOrigin - y;\n  return Math.sqrt(a * a + b * b);\n}\n\n// Sort points based off their distance from the origin. Not great as it could jump from 1,0 to 0,1\nexport function originDistance(points: SortablePoint[]): SortablePoint[] {\n  let distances_from_origin = points.map((p) => {\n    return { ...p, distance: distanceToPoint(0, 0, p.x, p.y) };\n  });\n  return distances_from_origin.sort((a, b) => a.distance - b.distance);\n}\n\n// Sorts points by going point to point based off the closest left-over points. Starts at 0,0.\nexport function nearestNeighbourFromOrigin(points: SortablePoint[]): SortablePoint[] {\n  if (points.length === 0) {\n    return [];\n  }\n\n  let nearest_point_to_origin = points.reduce(\n    (accumulator: SortablePoint, currentValue: SortablePoint): SortablePoint => {\n      let acc_dist = distanceToPoint(0, 0, accumulator.x, accumulator.y);\n      let curr_dist = distanceToPoint(0, 0, currentValue.x, currentValue.y);\n      return acc_dist > curr_dist ? currentValue : accumulator;\n    }\n  );\n\n  let sorted_points: SortablePoint[] = [nearest_point_to_origin]; // Put the closest point to 0, 0 in the sorted list\n  let points_left: SortablePoint[] = points.slice(); // Make a copy\n  points_left = points_left.filter((p) => p.id !== nearest_point_to_origin.id); // Remove nearest point\n\n  let current_point: SortablePoint = nearest_point_to_origin;\n  const reduce_to_closest_point = (\n    accumulator: SortablePoint,\n    currentValue: SortablePoint\n  ): SortablePoint => {\n    // Keep function out of the loop\n    let acc_dist = distanceToPoint(current_point.x, current_point.y, accumulator.x, accumulator.y);\n    let curr_dist = distanceToPoint(\n      current_point.x,\n      current_point.y,\n      currentValue.x,\n      currentValue.y\n    );\n    return acc_dist > curr_dist ? currentValue : accumulator;\n  };\n  while (points_left.length > 0) {\n    let closest_point: SortablePoint = points_left.reduce(reduce_to_closest_point);\n    sorted_points.push(closest_point);\n    points_left = points_left.filter((p) => p.id !== closest_point.id);\n    current_point = closest_point;\n  }\n\n  return sorted_points;\n}\n\n// Return the data provided\nexport function noSort(points: SortablePoint[]): SortablePoint[] {\n  return points;\n}\n\n// Sort by x\nexport function xAxis(points: SortablePoint[]): SortablePoint[] {\n  return points.sort((a, b) => {\n    return a.x === b.x ? 0 : a.x > b.x ? 1 : -1;\n  });\n}\n\n// Sort by y\nexport function yAxis(points: SortablePoint[]): SortablePoint[] {\n  return points.sort((a, b) => {\n    return a.y === b.y ? 0 : a.y > b.y ? 1 : -1;\n  });\n}\n\n// Sort tracks given x and y features and a sorting method\nexport function sort(\n  tracks: TrackWithAudioFeatures[],\n  x_audio_feature: keyof SpotifyApi.AudioFeaturesObject,\n  y_audio_feature: keyof SpotifyApi.AudioFeaturesObject,\n  sorting_method: Function\n): IndexedTrackId[] {\n  // Get points initial indexes (to calculate movement)\n  let tracks_with_playlist_indexes: IndexedTrackId[] = tracks.map((t, i) => {\n    return { id: t.id, index: { before: i, after: 0 } };\n  });\n\n  // Convert tracks to sortable points\n  let tracks_as_sp: SortablePoint[] = tracks.map((t) => {\n    if (t.audio_features !== undefined && t.audio_features !== null) {\n      let x = t.audio_features[x_audio_feature] as number; // We know better than the compiler\n      let y = t.audio_features[y_audio_feature] as number;\n      return { id: t.id, x: x, y: y };\n    } else {\n      // Commonly occurs as t.audioFeatures === undefined on first playlist selection\n      return { id: t.id, x: 0, y: 0 };\n    }\n  });\n\n  // Sort the sortable points\n  let tracks_as_sp_sorted: SortablePoint[] = sorting_method(tracks_as_sp);\n\n  // Calculate new indexes using the sorted points\n  let tracks_with_sorted_indexes: IndexedTrackId[] = tracks_as_sp_sorted\n    .map((sp, i) => {\n      let track = tracks_with_playlist_indexes.find((t) => t.id === sp.id);\n      if (track !== undefined) {\n        return { ...track, index: { before: track.index.before, after: i } };\n      } else {\n        console.error(\"[TrackTable:tracks_with_sorted_indexes] Cannot find match for: \" + sp.id);\n        return null;\n      }\n    })\n    .filter((t: IndexedTrackId | null): t is IndexedTrackId => t !== null);\n\n  // Quick debugging verification\n  if (tracks_with_sorted_indexes.length !== tracks.length) {\n    console.error(\"PointSorting.sort did not output the same amount of tracks input\");\n  }\n\n  // Sort tracks by the new indexes\n  return tracks_with_sorted_indexes.sort((a, b) => a.index.after - b.index.after);\n}\n"]},"metadata":{},"sourceType":"module"}